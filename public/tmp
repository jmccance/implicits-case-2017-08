Introduction. My name is Joel McCance. I'm a senior engineer here at Pandera, as of, oh, [look at watch] about 80 hours ago. I started writing Scala professionally two or three years ago on a few consulting projects I was lucky enough to be staffed on and the language has really captured my imagination. There's so many new ways to do things and new ways of thinking about how we write programs.

Implicits are interesting because they're a very uncommon language feature. Lots of languages have functions. Lots of languages have objects, classes, inheritance. Too many languages have annotations. You can even find type classes in a lot of languages these days. But I've only been able to find two languages that have an explicit concept of implicits: Scala and Agda. And Scala's implementation is the richest, most fully realized version of the concept. Odersky called them "the feature that most makes Scala, Scala", and I agree with him. Implicits have shaped how people write libraries for the language, and enabled some extremely powerful patterns that just aren't feasible otherwise. Implicits provide the machinery to power everything from banal uses like ExecutionContext, all the way through to the immense power of Shapeless, a library that has stretched the limits of implicits so far that Miles Sabin has been making contributions to the compiler to improve their performance and usability.

---

Before we talk about the use cases for implicits, or the new shinies coming down the pipe in the form of implicit functions, I want to make sure everyone is on the same page on what implicits are and how they work.

Right now in Scala, there are essentially four kinds of implicit "things" in Scala:

- Implicit parameters
- Implicit values
- Implicit conversions
- Implicit classes

Implicit parameters are all about reducing boilerplate. In functional languages like Scala, we often want to pass everything in as a parameter, since otherwise you can't interact with it and remain a pure function. But this can easily add up to a lot of boring repetition. This is annoying to write, annoying to update, and annoying to read.

Implicit parameters allow us to factor out these parameters that we want to pass in everywhere they're relevant, without having to move them into some sort of global state. Instead we just say "If I don't tell you what I want here explicitly, I assume I want this one."

A common example of this is ExecutionContext. If you've done any programming with Futures in Scala, you've probably run into this. At the very least you've gotten the compilation error telling you to import the global ExecutionContext and learned how to make that error go away. Without implicits, the Futures API would look something like this:

```scala
someFuture
  .map(f)(ec)
  .flatMap(g(x)(ec))(ec)
  /* etc */
```

This would obviously get old. But thankfully, implicit parameters mean we don't have to do it this way.

Declaring an implicit parameter looks like this:

```scala
def f(a1: X, a2: Y)(implicit i1: I, i2: J): A
```

Note that this builds on another feature of Scala, which is that you can have multiple parameter lists on a single function. The implicit parameter list has to come last, and you can only have one implicit parameter list (though it can contain however many parameters you need). 

---

Implicit values are how we populate the implicit arguments.


---

Debugging implicits